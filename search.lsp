#|**************************** SEARCH.LSP *************************************

 General-purpose exhaustive search routine includes both breadth-first
 search and depth-first search. Uses graph search with OPEN and CLOSED
 lists rather than tree search, to avoid cycles. Does not use heuristics
 to limit or guide search.

 To solve a specific problem, the functions "generate-successors" and
 "goal-state" must be defined. "Generate-successors" takes a state as its
 argument and returns a list of child states. "Goal-state?" returns T if
 its argument is a goal state, NIL otherwise.

 In order to retrace a solution path, nodes are stored as (state parent)
 pairs, where "state" is the current state and "parent" is the parent
 state. Given a goal node, a solution path is generated by simply tracing
 backwards through the parent states.

 Author: John M. Weiss, Ph.D.
 Written Spring 2016 for CSC447/547 AI class.

 Modifications:
 Stephanie Athow: added a Depth-First-Iterated-Deepening option
 
*****************************************************************************|#

#|*****************************************************************************
  Structure: Node

  Authors: Dr. John Weiss, Stephanie Athow

  Description: Stores state, parent, and depth the state was generated
*****************************************************************************|#
	(defstruct node state parent depth)

#|*****************************************************************************
  Function: equal-states

  Author: Dr. John Weiss

  Description:  Test if two nodes have the same state.

  Args:
	n1:	node 1
	n2: node 2
*****************************************************************************|#
	(defun equal-states (n1 n2) (equal (node-state n1) (node-state n2)))

#|*****************************************************************************
  Function: search_bfs_dfs

  Authors: Dr. John Weiss, Stephanie Athow

  Description:  Given a start state and a search type (BFS or DFS), return a 
	path from the  start to the goal. The depth option is for the DFID search 
	option.

  Args:
	start:	start state of puzzle
	type:   run the bfs or dfs search
	depth:  optional argument for bounding the DFID search
*****************************************************************************|#
(defun search_bfs_dfs (start type &optional(depth -1) )
	(do* 															; note use of sequential DO*
		(															; initialize local loop vars
			(depth-count 0 (setf depth-count(+ 1 depth-count)))		; depth count for DFID
			(curNode (make-node :state start :parent nil :depth 0)) ; current node: (start nil)
			(OPEN (list curNode))                           		; OPEN list: ((start nil))
			(CLOSED nil)                                    		; CLOSED list:  ( )
			(flag_cont nil)
		)

		; termination condition - return solution path when goal is found
		((equal *goal* (node-state curNode)) (build-solution curNode CLOSED))

		; loop body
		(when (null OPEN) (return nil))   		          	; no solution

		(setf curNode (car OPEN))
		(setf OPEN (cdr OPEN))
		(setf CLOSED (cons curNode CLOSED))
		(setf *expandedCount* (+ 1 *expandedCount*))

		; add successors of current node to OPEN
		(dolist (child (generate-successors (node-state curNode)))

			; for each child node
			(setf child (make-node :state child :parent (node-state curNode) :depth (1+ (node-depth curNode))))

			; if the node is not on OPEN or CLOSED
			(if (and (not (member child OPEN   :test #'equal-states) )
				(not (member child CLOSED :test #'equal-states) ) )

				; add it to the OPEN list
				(cond

					; BFS - add to end of OPEN list (queue)
					((eq type 'bfs) 
						(setf OPEN (append OPEN (list child ))) (setf *distinctNodes* (+ 1 *distinctNodes*))
					)

					; DFID - add to start of OPEN list (stack) so long as depth of child is
					;  less than the depth of the iteration
					((eq type 'dfs) 
						(if (<= (node-depth child) depth )
						(setf OPEN (cons child OPEN)) (setf *distinctNodes* (+ 1 *distinctNodes*)))
					)
					; error handling for incorrect usage
					(t (format t "SEARCH: bad search type! ~s~%" type) (return nil))
				)
			)
		)
	)
)
#|*****************************************************************************
  Function: search_dfid

  Author: Dr. John Weiss

  Description: Given a start state, search for the goal using DFS with a depth
	bound. Also reset generatedCount, expandedCount and distinctNodes for each 
	iteration so we get the final stats

  Args:
	start:	start state for search
*****************************************************************************|#
(defun search_dfid (start)
	(do*
		(
			(start-node start)					; start node 
			(depth 1 (setf depth(+ 1 depth))) 	; restrict depth of dfs search
			(answer nil)						; hold answer to return
		)

		; if solution found, return answer 
		( (not (null answer) ) (return answer) )

		; reset stats
		(setf *generatedCount* 0)
		(setf *expandedCount* 0)
		(setf *distinctNodes* 0)

		; run DFID for next layer bound
		(setf answer (search_bfs_dfs start-node 'dfs depth) )
		answer
	)
)

#|*****************************************************************************
  Function: build-solution

  Author: Dr. John Weiss

  Description: Build-solution takes a state and a list of (state parent) pairs
	and constructs the list of states that led to the current state
	by tracing back through the parents to the start node (nil parent).

  Args:
	node:		goal node with parent field pointing to successor
	node-list:	list of expanded nodes
*****************************************************************************|#
(defun build-solution (node node-list)
	(do
		((path (list (node-state node))))        ; local loop var
		((null (node-parent node)) path)         ; termination condition

		; find the parent of the current node
		(setf node (member-state (node-parent node) node-list))

		; add it to the path
		(setf path (cons (node-state node) path))
	)
)
#|*****************************************************************************
  Function: member-state

  Author: Dr. John Weiss

  Description: Looks for a node on the node-list with the same state.

  Args:
	state:		potential state generated
	node-list:	list of nodes, each node contains a state, parent of state and depth generated
*****************************************************************************|#
(defun member-state (state node-list)
	(dolist (node node-list)
	(when (equal state (node-state node)) (return node))
	)
)

